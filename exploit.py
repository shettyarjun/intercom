#!/usr/bin/env python3

import requests
import re
import argparse
import sys
from urllib3.exceptions import InsecureRequestWarning
from termcolor import colored
from concurrent.futures import ThreadPoolExecutor
import time

# SSL warnings suppress (not recommended for production)
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

# Default headers
HEADERS = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:71.0) Gecko/20100101 Firefox/71.0",
    "Accept": "*/*",
    "Accept-Language": "en",
    "Accept-Encoding": "gzip",
    "Connection": "close"
}

# Default email for testing
USER_EMAIL = "test@gmail.com"

def print_info(message):
    print(colored(f"[*] {message}", "blue"))

def print_success(message):
    print(colored(f"[+] {message}", "green"))

def print_error(message):
    print(colored(f"[-] {message}", "red"))

def extract_app_id(response_text):
    """Extract Intercom app_id from the response body."""
    pattern = r'app_id:\s*"([a-zA-Z0-9\-]+)"'
    match = re.search(pattern, response_text)
    return match.group(1) if match else None

def check_single_url(url):
    """Check a single URL for Intercom Identity Verification Misconfiguration."""
    print_info(f"Scanning: {url}")

    try:
        # Step 1: Get the main page to extract app_id
        response = requests.get(url, headers=HEADERS, verify=False, allow_redirects=True, timeout=10)
        app_id = extract_app_id(response.text)
        if not app_id:
            return False  # Skip non-vulnerable URLs

        print_success(f"Found Intercom app_id: {app_id}")

        # Step 2: Send request to Intercom API
        intercom_url = "https://api-iam.intercom.io/messenger/web/ping"
        body = f'app_id={app_id}&user_data={{"email":"{USER_EMAIL}"}}'
        response = requests.post(intercom_url, headers=HEADERS, data=body, verify=False, timeout=10)

        if response.status_code == 200:
            print_success(f"\n[!] Vulnerable Target Found: {url}")
            print_success(f"  - Request:")
            print_success(f"    URL: {intercom_url}")
            print_success(f"    Headers: {HEADERS}")
            print_success(f"    Body: {body}\n")

            print_success(f"  - Response:")
            print_success(f"    Status Code: {response.status_code}")
            print_success(f"    Response Body: {response.text[:500]}...\n")

            return True
        return False

    except Exception as e:
        print_error(f"Error scanning {url}: {str(e)}")
        return False

def read_urls_from_file(file_path):
    """Read URLs from a file and return a list."""
    try:
        with open(file_path, 'r') as file:
            return [line.strip() for line in file if line.strip()]
    except Exception as e:
        print_error(f"Error reading file {file_path}: {str(e)}")
        sys.exit(1)

def scan_urls(urls):
    """Scan a list of URLs, showing details only for vulnerable ones."""
    vulnerable_urls = []

    with ThreadPoolExecutor(max_workers=5) as executor:
        future_to_url = {executor.submit(check_single_url, url): url for url in urls}
        for future in future_to_url:
            url = future_to_url[future]
            try:
                result = future.result()
                if result:  # Only show results for vulnerable URLs
                    vulnerable_urls.append(url)
            except Exception as e:
                print_error(f"Error scanning {url}: {str(e)}")

    if vulnerable_urls:
        print("\n" + "="*50)
        print_success(f"Vulnerable URLs ({len(vulnerable_urls)}):")
        for url in vulnerable_urls:
            print_success(f"  - {url}")
        print("="*50 + "\n")
    else:
        print_error("No vulnerable URLs found.")

    return vulnerable_urls

def main():
    parser = argparse.ArgumentParser(description="IntercomVulnChecker - Scan for Intercom Identity Verification Misconfiguration")
    parser.add_argument("-u", "--url", help="Single URL to scan")
    parser.add_argument("-f", "--file", help="File containing list of URLs to scan")
    args = parser.parse_args()

    if not args.url and not args.file:
        print_error("Please provide a URL (-u) or a file with URLs (-f)")
        parser.print_help()
        sys.exit(1)

    urls = [args.url] if args.url else read_urls_from_file(args.file)

    print_info(f"Total URLs to scan: {len(urls)}")
    start_time = time.time()
    scan_urls(urls)
    print_info(f"Scan completed in {time.time() - start_time:.2f} seconds")

if __name__ == "__main__":
    main()
